from abc import ABC, abstractmethod
from typing import List, Tuple, Any, Dict
from simulation.analysis import Analyzer


# ---------------------------------------------------------
# Message Class
# ---------------------------------------------------------
class Message:
    def __init__(self, msg_id, sender_id, receiver_id, create_time, content=""):
        self.id = msg_id
        self.sender_id = sender_id
        self.receiver_id = receiver_id
        self.create_time = create_time
        self.deliver_time = None
        self.content = content

    def mark_delivered(self, time):
        self.deliver_time = time

    def __repr__(self):
        return f"<Msg {self.id}: {self.sender_id}->{self.receiver_id} content={self.content}>"


# --- Abstract Interfaces (Protocol, Scheduler, TrafficGenerator) ---

# ---------------------------------------------------------
# Protocol Interface
# ---------------------------------------------------------
class Protocol(ABC):
    """
    Defines HOW a process reacts to a message.
    """

    @abstractmethod
    def handle_message(self, my_pid: int, msg: Message, network_n: int) -> List[Tuple[int, Any]]:
        """
        Process an incoming message and determine the reaction.

        Args:
            my_pid: The ID of the process executing this logic.
            msg: The message being received.
            network_n: Total number of processes in the network.

        Returns:
            A list of tuples, where each tuple contains:
            (target_receiver_id, content_of_response)
        """
        pass


# ---------------------------------------------------------
# Scheduler Interface
# ---------------------------------------------------------
class Scheduler(ABC):
    def __init__(self):
        pass

    @abstractmethod
    def send_pending_message(self) -> Message | None:
        """
            Selects and returns the next message to be delivered based on the scheduling algorithm.
            A single message is delivered in each global time unit.
            Returns None if no messages are pending.
        """
        pass

    @abstractmethod
    def add_message(self, msg: Message):
        pass

    @abstractmethod
    def has_pending_messages(self) -> bool:
        """Returns True if there is at least one message waiting in the network."""
        pass

    @abstractmethod
    def get_pending_links_count(self) -> int:
        """Returns the number of links (sender->receiver) that have messages waiting."""
        pass

    @abstractmethod
    def get_pending_messages_count(self) -> int:
        """Returns the total number of messages waiting across the entire system."""
        pass


# ---------------------------------------------------------
# TrafficGenerator Interface
# ---------------------------------------------------------
class TrafficGenerator(ABC):
    """
    Abstract Base Class for traffic initialization strategies.
    Allows switching between different communication scenarios (All-to-All, One-to-One, etc.).
    """

    @abstractmethod
    def generate(self, network: 'Network'):
        """
        Generates the initial messages and injects them into the network.
        Args:
            network: The Network instance to inject messages into.
        """
        pass


# ---------------------------------------------------------
# Process Class
# ---------------------------------------------------------
class Process:
    def __init__(self, pid: int, my_protocol: Protocol, n: int):
        self.id = pid
        self.protocol = my_protocol
        self.n = n

    def handle_received_message(self, msg: Message) -> List[Tuple[int, Any]]:
        """
        Delegates logic to the protocol.
        Returns:
            A list of (receiver_id, content) tuples representing new messages to be sent.
            The messages will be generated by the network and passed to the scheduler.
        """
        return self.protocol.handle_message(self.id, msg, self.n)


# ---------------------------------------------------------
# Network Class
# ---------------------------------------------------------
class Network:
    def __init__(self, scheduler: Scheduler, n: int):
        self.global_time = 0
        self.scheduler = scheduler
        self.n = n
        self.processes: Dict[int, Process] = {}
        self.logs: List[Dict[str, Any]] = []
        self.msg_id_counter = 0

    def initialize_processes(self, protocol: Protocol):
        """Creates N processes with the specific protocol."""
        for i in range(self.n):
            self.processes[i] = Process(i, protocol, self.n)

    def create_initial_message(self, sender_id, receiver_id, content):
        """Helper to kickstart the simulation."""
        msg = Message(self.msg_id_counter, sender_id, receiver_id, self.global_time, content)
        self.msg_id_counter += 1
        self.scheduler.add_message(msg)
        self.log_msg(msg)

    def log_msg(self, msg: Message):
        event = "DELIVERED" if msg.deliver_time is not None else "CREATED"
        delay = (msg.deliver_time - msg.create_time) if msg.deliver_time is not None else None

        log_entry = {
            "event_type": event,
            "message_id": msg.id,
            "sender_id": msg.sender_id,
            "receiver_id": msg.receiver_id,
            "create_time": msg.create_time,
            "delay": delay,
            "content": msg.content
        }
        self.logs.append(log_entry)

    def log_step_stats(self):
        """Logs the system state at the end of a step."""
        log_entry = {
            "event_type": "STEP_STATS",
            "global_time": self.global_time,
            "pending_links": self.scheduler.get_pending_links_count(),
            "total_pending_messages": self.scheduler.get_pending_messages_count()
        }
        self.logs.append(log_entry)

    def run_step(self):
        """Executes exactly one event delivery."""
        if not self.scheduler.has_pending_messages():
            print("No more messages to deliver.")
            return False

        # Scheduler picks a message to deliver
        msg = self.scheduler.send_pending_message()
        if not msg:
            return False

        # Advance global time and mark delivered
        self.global_time += 1
        msg.mark_delivered(self.global_time)
        self.log_msg(msg)

        # Process handles message using its protocol to generate new traffic
        # Then, the network asks the scheduler to schedule each generated response
        receiver_process = self.processes[msg.receiver_id]
        raw_responses = receiver_process.handle_received_message(msg)

        for target_id, content in raw_responses:
            new_msg = Message(
                msg_id=self.msg_id_counter,
                sender_id=receiver_process.id,
                receiver_id=target_id,
                create_time=self.global_time,
                content=content
            )
            self.msg_id_counter += 1

            self.scheduler.add_message(new_msg)
            self.log_msg(new_msg)

        self.log_step_stats()
        return True


# ---------------------------------------------------------
# Simulator Class
# ---------------------------------------------------------
class Simulator:
    """
    Encapsulates the simulation environment.
    Responsible for initialization, execution, and providing analysis tools.
    """

    def __init__(self, n: int, protocol: Protocol, traffic_generator: TrafficGenerator, scheduler: Scheduler):
        """
        Initialize the simulation environment.

        Args:
            n: Number of processes.
            protocol: The behavior strategy for processes. For now, we allow a single protocol of all process.
            traffic_generator: Strategy for initial traffic.
            scheduler: The scheduling algorithm instance.
        """
        self.n = n
        self.scheduler = scheduler
        self.network = Network(self.scheduler, self.n)
        self.network.initialize_processes(protocol)
        self.traffic_generator = traffic_generator
        self.analyzer = Analyzer(self.network)

    def run(self, max_steps: int) -> int:
        """
        Runs the simulation.

        1. Triggers traffic generation.
        2. Runs the loop for `max_steps`.

        Returns:
            The number of steps actually executed.
        """
        # 1. Generate Initial Traffic
        self.traffic_generator.generate(self.network)

        print(f"--- Starting Simulation Loop (Max Steps: {max_steps}) ---")
        steps_executed = 0
        for _ in range(max_steps):
            if not self.network.run_step():
                print("Simulation stopped: No more pending messages.")
                break
            steps_executed += 1

        print(f"--- Simulation Finished after {steps_executed} steps ---")
        return steps_executed

    def print_logs(self, limit=10):
        print(f"\n--- Message Delivery Logs (First {limit} Steps) ---")
        delivered = [x for x in self.network.logs if x['event_type'] == "DELIVERED"]
        for l in delivered[:limit]:
            print(
                f"Time {l['create_time']}->{l['create_time'] + l['delay']}: From pid {l['sender_id']} to pid {l['receiver_id']} (Delay: {l['delay']})")

        print(f"\n--- Network Logs (First {limit} Steps) ---")
        stats = [x for x in self.network.logs if x['event_type'] == "STEP_STATS"]
        for stat in stats[:limit]:
            print(f"Step {stat['global_time']}: ",
                  f"Pending links: {stat['pending_links']}, ",
                  f"pending messages: {stat['total_pending_messages']}")
